#ifndef _RADAR_TRACKER_MATLAB_WRAPPER_HEADER_
#define _RADAR_TRACKER_MATLAB_WRAPPER_HEADER_

#include <array>
#include <tf2/LinearMath/Transform.h>
#include <tf2/LinearMath/Quaternion.h>
#include <tf2/impl/utils.h>
#include <radar_tracker.h>
#include <radar_tracker_init.h>
#include <radar_tracker_initialize.h>

#include "rclcpp/rclcpp.hpp"

//tf rm, lnl
#ifndef TF_SWITCH_ON
#define TF_SWITCH_ON 0
#endif

// Important constants, as these are (currently) not autogenerated by Matlab. So we must manually take care to be consistent here!
const int NUM_RADAR_OBJECTS = 50;
const int NUM_RADAR_LOCATIONS = 512;

//std chrono time 
const std::chrono::seconds duration_1sec(1);
const std::chrono::milliseconds duration_70ms (70);
const std::chrono::milliseconds duration_500ms (500);

//! typedef boost::array<float, 81> cov3d;
typedef std::array<float, 81> cov3d;

class CRadarTrackerMatlabWrapper
{
private:
  // Time stamp of last locations
  //! ros::Time m_t_last_measurement;
  rclcpp::Time m_t_last_measurement;

  //! ros::Duration m_current_dt;
  // rclcpp::Duration m_current_dt{(rcl_duration_value_t)1.0};
  rclcpp::Duration m_current_dt{duration_1sec};  

  // Matlab-Objektliste
  OBJECT_STRUCT m_obj_list_ast[NUM_RADAR_OBJECTS];

  // Input list for the Matlab tracker containing DSP measurements
  MEASLIST_STRUCT m_meas_list_st;
  #if TF_SWITCH_ON
  // Transform  from vehicle coord to sensor
  tf2::Transform m_transformSensor;
  #endif

public:
  CRadarTrackerMatlabWrapper();
  ~CRadarTrackerMatlabWrapper();

  // get() for matlab: OBJECT_STRUCT m_obj_list_ast
  double getObjValid(std::size_t idx) const {return m_obj_list_ast[idx].valid;}
  double getObjPExist(std::size_t idx) const {return m_obj_list_ast[idx].pexist;}
  void getObjPos(std::size_t idx, double & px, double & py) const {px = m_obj_list_ast[idx].x[0]; py = m_obj_list_ast[idx].x[3];} // object position
  void getObjVel(std::size_t idx, double & vx, double & vy) const {vx = m_obj_list_ast[idx].x[1]; vy = m_obj_list_ast[idx].x[4];} // object velocity
  void getObjAcc(std::size_t idx, double & ax, double & ay) const {ax = m_obj_list_ast[idx].x[2]; ay = m_obj_list_ast[idx].x[5];} // object acceleration
  double getObjLength(std::size_t idx) const {return m_obj_list_ast[idx].length;}
  double getObjWidth(std::size_t idx) const {return m_obj_list_ast[idx].width;}
  double getObjPsi(std::size_t idx) const {return m_obj_list_ast[idx].psi;}
  double getObjPsiDt(std::size_t idx) const {return m_obj_list_ast[idx].psiDt;}
  double getObjHist(std::size_t idx) const {return m_obj_list_ast[idx].hist;}
  cov3d getObj3DCovariance(std::size_t idx) const;
  double getObjPsiVariance(std::size_t idx) const {return m_obj_list_ast[idx].P_psi[0];}
  double getObjPsiDtVariance(std::size_t idx) const {return m_obj_list_ast[idx].P_psi[3];} // covariance of psi and psiDt is 0 anyway...
  double getSensorMountingAng()  const {return m_meas_list_st.ang_sens_offset; }

    // Clear all Measurement data (Locations, FOV, time stamps...)
  void clearMeasurementData();

#if TF_SWITCH_ON
  // Sensor mounting position and orientation, is used by the tracker internally
  void setSensorTransform(tf2::Transform transformSensor) ;
#endif

  // Copy location data from Radar detection into the internal Matlab structs for further proceeding
  // Important: All items in sensor coordinates!
  void setLocationData(
      std::size_t locIdx,
      bool Measured,
      double dMeas,
      double dVarMeas,
      double vMeas,
      double vVarMeas,
      double dbRCS,
      double alpAng,
      double alpVarAng);

  void setEgoData(
      double vx,
      double ax,
      double psiDt,
      double kapCurvTraj,
      double alpSideSlipAngle);

  void setFovData(
      double fov_angle_elem,
      double fov_range_elem,
      std::size_t elems_ind);

  // Sets the time stamp of current measurement and computes the time passed since last measurement
  //	\input t_measurement time stamp of the meausrement
  void setTimeStampAndComputeDt(rclcpp::Time t_measurement/*, rclcpp::Clock& t_last_measurement*/);  //lnl debug

  // Executes one cycle of the tracker
  void runTrackingCycle();

protected:
};

#endif
